{"ast":null,"code":"\"use strict\";\n/**\n * Returns `true` if `value` is `undefined`.\n * @examples\n *    var foo; isUndefined(foo); // true\n *    isUndefined(0); // false\n */\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nexports.isUndefined = isUndefined;\n/**\n * Returns `true` if value is `null`.\n * @examples\n *    isNull(null); // true\n *    isNull(undefined); // false\n */\n\nfunction isNull(value) {\n  return value === null;\n}\n\nexports.isNull = isNull;\n/**\n * Returns `true` if value is a string.\n * @examples\n *    isString(\"moe\"); // true\n */\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\nexports.isString = isString;\n/**\n * Returns `true` if `value` is a number.\n * @examples\n *    isNumber(8.4 * 5); // true\n */\n\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\nexports.isNumber = isNumber;\n/**\n * Returns `true` if `value` is a `RegExp`.\n * @examples\n *    isRegExp(/moe/); // true\n */\n\nfunction isRegExp(value) {\n  return instanceOf(value, RegExp);\n}\n\nexports.isRegExp = isRegExp;\n/**\n * Returns true if `value` is a `Date`.\n * @examples\n *    isDate(new Date()); // true\n */\n\nfunction isDate(value) {\n  return isObject(value) && instanceOf(value, Date);\n}\n\nexports.isDate = isDate;\n/**\n * Returns true if object is a Function.\n * @examples\n *    isFunction(function foo(){}) // true\n */\n\nfunction isFunction(value) {\n  return typeof value === \"function\" && value.call && value.apply;\n}\n\nexports.isFunction = isFunction;\n/**\n * Returns `true` if `value` is an object (please note that `null` is considered\n * to be an atom and not an object).\n * @examples\n *    isObject({}) // true\n *    isObject(null) // false\n */\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nexports.isObject = isObject;\n/**\n * Returns true if `value` is an Array.\n * @examples\n *    isArray([1, 2, 3])  // true\n *    isArray({ 0: \"foo\", length: 1 }) // false\n */\n\nvar isArray = Array.isArray || function isArray(value) {\n  Object.prototype.toString.call(value) === \"[object Array]\";\n};\n\nexports.isArray = isArray;\n/**\n * Returns `true` if `value` is an Arguments object.\n * @examples\n *    (function(){ return isArguments(arguments); })(1, 2, 3); // true\n *    isArguments([1,2,3]); // false\n */\n\nfunction isArguments(value) {\n  Object.prototype.toString.call(value) === \"[object Arguments]\";\n}\n\nexports.isArguments = isArguments;\n/**\n * Returns true if it is a primitive `value`. (null, undefined, number,\n * boolean, string)\n * @examples\n *    isPrimitive(3) // true\n *    isPrimitive(\"foo\") // true\n *    isPrimitive({ bar: 3 }) // false\n */\n\nfunction isPrimitive(value) {\n  return !isFunction(value) && !isObject(value);\n}\n\nexports.isPrimitive = isPrimitive;\n/**\n * Returns `true` if given `object` is flat (it is direct decedent of\n * `Object.prototype` or `null`).\n * @examples\n *    isFlat({}) // true\n *    isFlat(new Type()) // false\n */\n\nfunction isFlat(object) {\n  return isObject(object) && (isNull(Object.getPrototypeOf(object)) || isNull(Object.getPrototypeOf(Object.getPrototypeOf(object))));\n}\n\nexports.isFlat = isFlat;\n/**\n * Returns `true` if object contains no values.\n */\n\nfunction isEmpty(object) {\n  if (isObject(object)) {\n    for (var key in object) return false;\n\n    return true;\n  }\n\n  return false;\n}\n\nexports.isEmpty = isEmpty;\n/**\n * Returns `true` if `value` is an array / flat object containing only atomic\n * values and other flat objects.\n */\n\nfunction isJSON(value, visited) {\n  // Adding value to array of visited values.\n  (visited || (visited = [])).push(value); // If `value` is an atom return `true` cause it\"s valid JSON.\n\n  return isPrimitive(value) || // If `value` is an array of JSON values that has not been visited\n  // yet.\n  isArray(value) && value.every(function (element) {\n    return isJSON(element, visited);\n  }) || // If `value` is a plain object containing properties with a JSON\n  // values it\"s a valid JSON.\n  isFlat(value) && Object.keys(value).every(function (key) {\n    var $ = Object.getOwnPropertyDescriptor(value, key); // Check every proprety of a plain object to verify that\n    // it\"s neither getter nor setter, but a JSON value, that\n    // has not been visited yet.\n\n    return (!isObject($.value) || !~visited.indexOf($.value)) && !(\"get\" in $) && !(\"set\" in $) && isJSON($.value, visited);\n  });\n}\n\nexports.isJSON = function (value) {\n  return isJSON(value);\n};\n/**\n * Returns if `value` is an instance of a given `Type`. This is exactly same as\n * `value instanceof Type` with a difference that `Type` can be from a scope\n * that has a different top level object. (Like in case where `Type` is a\n * function from different iframe / jetpack module / sandbox).\n */\n\n\nfunction instanceOf(value, Type) {\n  var isConstructorNameSame;\n  var isConstructorSourceSame; // If `instanceof` returned `true` we know result right away.\n\n  var isInstanceOf = value instanceof Type; // If `instanceof` returned `false` we do ducktype check since `Type` may be\n  // from a different sandbox. If a constructor of the `value` or a constructor\n  // of the value\"s prototype has same name and source we assume that it\"s an\n  // instance of the Type.\n\n  if (!isInstanceOf && value) {\n    isConstructorNameSame = value.constructor.name === Type.name;\n    isConstructorSourceSame = String(value.constructor) == String(Type);\n    isInstanceOf = isConstructorNameSame && isConstructorSourceSame || instanceOf(Object.getPrototypeOf(value), Type);\n  }\n\n  return isInstanceOf;\n}\n\nexports.instanceOf = instanceOf;\n/**\n * Function returns textual representation of a value passed to it. Function\n * takes additional `indent` argument that is used for indentation. Also\n * optional `limit` argument may be passed to limit amount of detail returned.\n * @param {Object} value\n * @param {String} [indent=\"    \"]\n * @param {Number} [limit]\n */\n\nfunction source(value, indent, limit, offset, visited) {\n  var result;\n  var names;\n  var nestingIndex;\n  var isCompact = !isUndefined(limit);\n  indent = indent || \"    \";\n  offset = offset || \"\";\n  result = \"\";\n  visited = visited || [];\n\n  if (isUndefined(value)) {\n    result += \"undefined\";\n  } else if (isNull(value)) {\n    result += \"null\";\n  } else if (isString(value)) {\n    result += \"\\\"\" + value + \"\\\"\";\n  } else if (isFunction(value)) {\n    value = String(value).split(\"\\n\");\n\n    if (isCompact && value.length > 2) {\n      value = value.splice(0, 2);\n      value.push(\"...}\");\n    }\n\n    result += value.join(\"\\n\" + offset);\n  } else if (isArray(value)) {\n    if (nestingIndex = visited.indexOf(value) + 1) {\n      result = \"#\" + nestingIndex + \"#\";\n    } else {\n      visited.push(value);\n      if (isCompact) value = value.slice(0, limit);\n      result += \"[\\n\";\n      result += value.map(function (value) {\n        return offset + indent + source(value, indent, limit, offset + indent, visited);\n      }).join(\",\\n\");\n      result += isCompact && value.length > limit ? \",\\n\" + offset + \"...]\" : \"\\n\" + offset + \"]\";\n    }\n  } else if (isObject(value)) {\n    if (nestingIndex = visited.indexOf(value) + 1) {\n      result = \"#\" + nestingIndex + \"#\";\n    } else {\n      visited.push(value);\n      names = Object.keys(value);\n      result += \"{ // \" + value + \"\\n\";\n      result += (isCompact ? names.slice(0, limit) : names).map(function (name) {\n        var _limit = isCompact ? limit - 1 : limit;\n\n        var descriptor = Object.getOwnPropertyDescriptor(value, name);\n        var result = offset + indent + \"// \";\n        var accessor;\n        if (0 <= name.indexOf(\" \")) name = \"\\\"\" + name + \"\\\"\";\n        if (descriptor.writable) result += \"writable \";\n        if (descriptor.configurable) result += \"configurable \";\n        if (descriptor.enumerable) result += \"enumerable \";\n        result += \"\\n\";\n\n        if (\"value\" in descriptor) {\n          result += offset + indent + name + \": \";\n          result += source(descriptor.value, indent, _limit, indent + offset, visited);\n        } else {\n          if (descriptor.get) {\n            result += offset + indent + \"get \" + name + \" \";\n            accessor = source(descriptor.get, indent, _limit, indent + offset, visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n\n          if (descriptor.set) {\n            if (descriptor.get) result += \",\\n\";\n            result += offset + indent + \"set \" + name + \" \";\n            accessor = source(descriptor.set, indent, _limit, indent + offset, visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n        }\n\n        return result;\n      }).join(\",\\n\");\n\n      if (isCompact) {\n        if (names.length > limit && limit > 0) {\n          result += \",\\n\" + offset + indent + \"//...\";\n        }\n      } else {\n        if (names.length) result += \",\";\n        result += \"\\n\" + offset + indent + \"\\\"__proto__\\\": \";\n        result += source(Object.getPrototypeOf(value), indent, 0, offset + indent);\n      }\n\n      result += \"\\n\" + offset + \"}\";\n    }\n  } else {\n    result += String(value);\n  }\n\n  return result;\n}\n\nexports.source = function (value, indentation, limit) {\n  return source(value, indentation, limit);\n};","map":null,"metadata":{},"sourceType":"script"}